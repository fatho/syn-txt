; This prelude is sourced by every interpreter instance.
; See interpreter.rs.


; Generate a list consisting of a range of values.
; Usage:
;  (range start stop)
;  (range start stop :step)
;
; Both start and stop are inclusive.
(define range
    (begin
        (define (range-up start stop step)
            (if (<= start stop)
                (cons start (range-up (+ start step) stop step))
                nil))
        (define (range-down start stop step)
            (if (>= start stop)
                (cons start (range-down (+ start step) stop step))
                nil))
        (lambda (start stop :step (step 1))
            (cond
                ((> step 0) (range-up start stop step))
                ((< step 0) (range-down start stop step))
                (#t nil)))))


; Reduce a function from the left.
; Example:
;   (reduce-left f x (list y z))
; evaluates as
;   (f (f x y) z)
(define (reduce-left f init list)
    (if (cons? list)
        (reduce-left f (f init (head list)) (tail list))
        init
    ))

; Reduce a function from the right.
; Example:
;   (reduce-right f (list x y) z)
; evaluates as
;   (f x (f y z))
(define (reduce-right f list init)
    (if (cons? list)
        (f (head list) (reduce-right f (tail list) init))
        init
    ))


; Map over a list with an index.
; Example:
;   (imap f (list x y z))
; is equivalent to:
;   (list (f 0 x) (f 1 y) (f 2 z))
(define imap
    (begin 
        (define (worker f i list)
            (if (cons? list)
                (cons (f i (head list)) (worker f (+ i 1) (tail list)))
                nil))
        (lambda (f list) (worker f 0 list))
    ))


(define (not b) (if b #f #t))

(define (even? num) (= 0 (% num 2)))
(define (odd? num) (= 1 (% num 2)))

; TODO: take varargs
(define (max a b) (if (> a b) a b))
(define (min a b) (if (< a b) a b))