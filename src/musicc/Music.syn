; Prelude with musical primitives
;
; Concepts:
;   - a `melody` is a list of notes with absolute timings
;   - concatenating two melodies plays both at the same time (as the absolute timings don't change)

; Create a note object with absolute timing.
(define (note :start start :length length :pitch pitch :velocity (velocity 1.0))
    ; The convention is that objects have a :__type__ key indicating its type.
    ; This type annotation is used when parsing the values in the host.
    (dict :__type__ "note" :start start :length length :pitch pitch :velocity velocity))

; Instantiate a synthesizer of type `name`, with the given synthesizer specific settings.
(define (synth :name name :params (param-dict (dict)))
    (dict :__type__ "synth" :name name :params param-dict))

(define __default-synth__
    (synth :name "test" :params (dict)))

; Create a track object
(define (track :notes notes :instrument (instrument __default-synth__))
    (dict :__type__ "track" :notes notes :instrument instrument))

; Create a song object
(define (song :bpm bpm :tracks tracks)
    (dict :__type__ "song" :bpm bpm :tracks tracks))

; Create a simple song with just one track
(define (song/simple :bpm bpm :notes notes :instrument (instrument __default-synth__))
    (song :bpm bpm :tracks (list (track :notes notes :instrument instrument))))

; Create an ASDR envelope, or just an AR envelope.
(define (envelope :attack attack :decay (decay 0.0) :sustain (sustain 1.0) :release release)
    (dict :__type__ "asdr" :attack attack :decay decay :sustain sustain :release release))


; A lowpass biquad filter
(define (biquad/lowpass :cutoff cutoff :q (q 0.7071))
    (dict :__type__ "biquad-filter" :name "lowpass" :cutoff cutoff :q q))

; An allpass biquad filter
(define (biquad/allpass)
    (dict :__type__ "biquad-filter" :name "allpass"))


; Compute the time when the last note of the given melody ends.
(define (last-note-end melody)
    (if (cons? melody)
        (begin
            (define note (head melody))
            (define this-end (+ (get note :start) (get note :length)))
            (define rest-end (last-note-end (tail melody)))
            (if (> this-end rest-end) this-end rest-end)
        )
        0))

; Move the start of a note by the given ofset
(define (shift offset note) (update note :start (+ (get note :start) offset)))
; Move all notes in this melody by the given offset 
(define (shift-all offset melody)
    (map (lambda (n) (shift offset n)) melody))

; Play two melodies in sequence.
(define (sequence first next :rest (rest 0))
    (define first-end (last-note-end first))
    (define (shift note) (update note :start (+ (get note :start) first-end rest)))
    (concat first (map shift next)))

; ; Play a list of melodies in sequence.
(define sequence-all
    (begin
        (define (go-next melodies offset)
            (if (cons? melodies)
                ; process next melody
                (go-one (head melodies) offset offset (tail melodies))
                nil
            ))
        (define (go-one melody cur-offset max-offset melodies)
            (if (cons? melody)
                (begin
                    (define note (head melody))
                    (define shifted-note (update note :start (+ (get note :start) cur-offset)))
                    (define this-end (+ (get shifted-note :start) (get note :length)))
                    (cons
                        ; shift the current note
                        (update note :start (+ (get note :start) cur-offset))
                        ; and shift the remaining notes
                        (go-one (tail melody) cur-offset (max max-offset this-end) melodies)
                    ))
                ; call the continuation
                (go-next melodies max-offset)))
        (lambda (melodies) (go-next melodies 0))))

; Transpose a single note by the given amount of semitones.
(define (transpose-note note semitones)
    (update note :pitch (transpose (get note :pitch) semitones)))

; Transpose a whole melody by the given amount of semitones.
(define (transpose-all melody semitones)
    (map (lambda (n) (transpose-note n semitones)) melody))

; Repeat a given melody `n` times at multiples of `len`.
(define (repeat n melody :length (len nil))
    ; TODO: make if without else
    (if (nil? len) 
        (set! len (last-note-end melody))
        (begin)
    )
    (concat-map 
        (lambda (i)
            (shift-all (* i len) melody))
        (range 0 (- n 1))))