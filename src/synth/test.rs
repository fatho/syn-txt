//! Exemplary implementation of a synthesizer.

use super::envelope::*;
use super::oscillator::*;
use super::tuning::*;

use crate::note::*;
use crate::wave::*;

pub struct TestSynth {
    /// Samples per second rate of the generated audio signal.
    sample_rate: f64,
    /// Reference note and frequency, determining the pitch of all other notes.
    tuning: Tuning,

    /// Evenlope for played notes
    envelope: ADSR,

    // /// Output gain of the synthesizer
    // gain: f64,

    // /// Number of oscillators per voice
    // unison: usize,
    // /// Detune offset for each additional unison voice
    // unison_detune: f64,
    /// Monotoneously increasing id used for identifying voices.
    voice_id: usize,
    active_voices: Vec<TestSynthVoice>,
}

/// Opaque handle indicating a playing voice.
#[derive(Debug, PartialEq, Eq)]
pub struct PlayHandle(usize);

struct TestSynthVoice {
    handle: PlayHandle,
    play_delay_samples: usize,
    release_delay_samples: usize,
    amplitude: f64,
    sine: Oscillator,
    saw1: Oscillator,
    saw2: Oscillator,
    envelope: EvalADSR,
}

impl TestSynth {
    pub fn new(sample_rate: f64) -> Self {
        TestSynth {
            tuning: Tuning::default(),
            envelope: ADSR {
                attack: 0.05,
                decay: 1.0,
                sustain: 0.5,
                release: 0.25,
            },
            sample_rate,
            voice_id: 0,
            active_voices: vec![],
        }
    }
}

impl TestSynth {
    /// Play a note on the synthesizer, starting `sample_delay` samples into
    /// the next `fill_buffer` call. It will also work if the next `fill_buffer`
    /// call produces fewer samples, but the playing note will already occupy
    /// resources. It is therefore a good idea to only call `play_note` just
    /// before the `fill_buffer` call where the note starts.
    ///
    /// This function returns a `PlayHandle` that can be used for notifying the
    /// synthesizer about a note that has been released.
    /// Any note with a non-zero sustain level in its envelope will keep playing
    /// indefinitely until released with `release_note`.
    pub fn play_note(&mut self, sample_delay: usize, note: Note, velocity: Velocity) -> PlayHandle {
        let detune = 2.0f64.powf(5.0 / 1200.0);
        let frequency = self.tuning.frequency(note);
        let handle = self.next_voice_id();
        self.active_voices.push(TestSynthVoice {
            handle: PlayHandle(handle.0),
            play_delay_samples: sample_delay,
            release_delay_samples: std::usize::MAX,
            amplitude: velocity.amplitude(),
            sine: Oscillator::new(WaveShape::Sine, self.sample_rate, frequency),
            saw1: Oscillator::new(WaveShape::Saw, self.sample_rate, frequency * 0.5 * detune),
            saw2: Oscillator::new(WaveShape::Saw, self.sample_rate, frequency * 0.5 / detune),
            envelope: self.envelope.instantiate(self.sample_rate),
        });
        handle
    }

    /// Release a note that was previously played using `play_note`.
    /// If a note has already been released, this has no effect.
    /// If a note has only been marked for release, the shorter release time is used.
    pub fn release_note(&mut self, sample_delay: usize, handle: PlayHandle) {
        if let Some(voice) = self.active_voices.iter_mut().find(|v| v.handle == handle) {
            voice.release_delay_samples = voice.release_delay_samples.min(sample_delay);
        }
    }

    fn next_voice_id(&mut self) -> PlayHandle {
        let h = PlayHandle(self.voice_id);
        self.voice_id += 1;
        h
    }

    /// Add the waveforms generated by the currently playing notes onto the buffer.
    pub fn fill_buffer(&mut self, output: &mut [Stereo<f64>]) {
        for out_sample in output.iter_mut() {
            let mut wave = 0.0;
            let voice_count = self.active_voices.len();
            for voice_index in (0..voice_count).rev() {
                wave += self.active_voices[voice_index].sample();
                if self.active_voices[voice_index].faded() {
                    log::trace!(
                        "removing faded voice {:?}",
                        self.active_voices[voice_index].handle
                    );
                    self.active_voices.swap_remove(voice_index);
                }
            }

            out_sample.left += wave;
            out_sample.right += wave;
        }
    }
}

impl TestSynthVoice {
    fn sample(&mut self) -> f64 {
        if self.play_delay_samples > 0 {
            self.play_delay_samples -= 1;
            0.0
        } else {
            if self.release_delay_samples > 0 {
                self.release_delay_samples -= 1;
            } else if !self.envelope.released() {
                log::trace!("released {:?}", self.handle);
                self.envelope.release();
            }
            let sine = self.sine.next_sample();
            let saw1 = self.saw1.next_sample();
            let saw2 = self.saw2.next_sample();

            let shape = sine * 0.5 + saw1 * 0.25 + saw2 * 0.25;
            let envelope = self.envelope.step();

            shape * envelope * self.amplitude
        }
    }

    fn faded(&self) -> bool {
        self.envelope.faded()
    }
}
